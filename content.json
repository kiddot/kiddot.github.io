{"meta":{"title":"Share","subtitle":null,"description":null,"author":"kiddot","url":"https://kiddot.github.io"},"pages":[{"title":"About","date":"2017-12-12T09:25:50.376Z","updated":"2017-12-12T08:40:40.637Z","comments":true,"path":"about/index.html","permalink":"https://kiddot.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-12-12T09:25:50.380Z","updated":"2017-12-12T08:40:40.637Z","comments":true,"path":"categories/index.html","permalink":"https://kiddot.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-12T09:25:50.380Z","updated":"2017-12-12T08:40:40.637Z","comments":true,"path":"tags/index.html","permalink":"https://kiddot.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"对象的创建、布局与访问","slug":"对象的创建、布局与访问","date":"2017-06-30T10:51:22.000Z","updated":"2017-12-13T13:46:51.445Z","comments":true,"path":"2017/06/30/对象的创建、布局与访问/","link":"","permalink":"https://kiddot.github.io/2017/06/30/对象的创建、布局与访问/","excerpt":"对象的创建、布局与访问","text":"对象的创建、布局与访问 一、创建1new People(); 这行代码背后的JVM操作： 类加载检查​ 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类的加载过程 为对象分配内存 ​ 对象所需内存的大小在类加载完成后便完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来 ​ 根据Java堆中是否有规整有两种内存的分配方式： 指针分配 Java堆中的内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存也就是把指针向空闲空间那边移动一段与内存大小相等的距离。 空闲列表 Java堆中的内存不是规整的，已使用的内存和空闲的内存相互交错。虚拟机必须维护一张列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。 分配内存时解决并发问题的两种方案 ​ 对象创建在虚拟机中时非常频繁的行为，即使是仅仅修改一个指针指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况 对分配内存空间的动作进行同步处理 把内存分配的动作按照线程划分为在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(TLAB) 内存空间初始化 虚拟机将分配到的内存空间都初始化为零值（不包括对象头）,如果使用了TLAB，这一工作过程也可以提前至TLAB分配时进行。 内存空间初始化保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 对象设置​ 虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。 在上面的工作都完成之后，从虚拟机的角度看，一个新的对象已经产生了。 但是从Java程序的角度看，对象的创建才刚刚开始方法还没有执行，所有的字段都还是零。 一般来说，执行new指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算产生出来。 二、对象内存的布局 ​ 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。 对象头 HotSpot虚拟机的对象头包括两部分信息 第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等 另外一个部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例数据 ​ 实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。 对齐填充 ​ 对齐填充并不是必然存在的，也没有特定的含义，仅仅起着占位符的作用。 三、对象的访问定位 ​ 建立对象是为了使用对象，我们的Java程序需要通过栈上的引用数据来操作堆上的具体对象。 目前主流的访问方式有使用句柄和直接指针两种。 使用句柄​ 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 直接指针​ 如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而引用中存储的直接就是对象地址。 优势：速度更快，节省了一次指针定位的时间开销。（由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本）","categories":[{"name":"jvm","slug":"jvm","permalink":"https://kiddot.github.io/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://kiddot.github.io/tags/jvm/"}]},{"title":"Java堆空间的分区","slug":"Java堆空间的分区","date":"2017-06-28T12:51:11.000Z","updated":"2017-12-13T13:46:35.841Z","comments":true,"path":"2017/06/28/Java堆空间的分区/","link":"","permalink":"https://kiddot.github.io/2017/06/28/Java堆空间的分区/","excerpt":"Java堆空间的分区","text":"Java堆空间的分区 Eden区 Eden区位于Java堆的年轻代，是新对象分配内存的地方，由于堆是所有线程共享的，因此在堆上分配内存需要加锁。而Sun JDK为提升效率，会为每个新建的线程在Eden上分配一块独立的空间由该线程独享，这块空间称为TLAB（Thread Local Allocation Buffer）。在TLAB上分配内存不需要加锁，因此JVM在给线程中的对象分配内存时会尽量在TLAB上分配。如果对象过大或TLAB用完，则仍然在堆上进行分配。如果Eden区内存也用完了，则会进行一次Minor GC（young GC）。 Survival from to Survival区与Eden区相同都在Java堆的年轻代。Survival区有两块，一块称为from区，另一块为to区，这两个区是相对的，在发生一次Minor GC后，from区就会和to区互换。在发生Minor GC时，Eden区和Survivalfrom区会把一些仍然存活的对象复制进Survival to区，并清除内存。Survival to区会把一些存活得足够旧的对象移至年老代。 老年代 老年代里存放的都是存活时间较久的，大小较大的对象，因此年老代使用标记整理算法。当年老代容量满的时候，会触发一次Major GC（full GC），回收年老代和年轻代中不再被使用的对象资源。 扩展一一、逃逸分析和TLAB 扩展：new出来的对象并不都是被分配在堆上。但是Java中的逃逸分析和TLAB，可以认为一定会分配在堆上。 TLAB： JVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB（Thread-local allocation buffer）。默认设定为占用Eden Space的1%。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。 二、Java对象分配的过程 编译器通过逃逸分析，确定对象是在栈上分配还是在堆上分配。如果是在堆上分配，则进入选项2. 如果tlab_top + size &lt;= tlab_end，则在在TLAB上直接分配对象并增加tlab_top 的值，如果现有的TLAB不足以存放当前对象则3. 重新申请一个TLAB，并再次尝试存放当前对象。如果放不下，则4. 在Eden区加锁（这个区是多线程共享的），如果eden_top + size &lt;= eden_end则将对象存放在Eden区，增加eden_top 的值，如果Eden区不足以存放，则5. 执行一次Young GC（minor collection）。 经过Young GC之后，如果Eden区任然不足以存放当前对象，则直接分配到老年代。 扩展二JVM 新生代为何需要两个 Survivor 空间？为什么不是0个 Survivor 空间？ 如果没有 Survivor 空间的话，垃圾收集将会怎样进行：一遍新生代 gc 过后，不管三七二十一，活着的对象全部进入老年代，即便它在接下来的几次 gc 过程中极有可能被回收掉。这样的话老年代很快被填满， Full GC 的频率大大增加。我们知道，老年代一般都会被规划成比新生代大很多，对它进行垃圾收集会消耗比较长的时间；如果收集的频率又很快的话，那就更糟糕了。基于这种考虑，虚拟机引进了“幸存区”的概念：如果对象在某次新生代 gc 之后任然存活，让它暂时进入幸存区；以后每熬过一次 gc ，让对象的年龄＋1，直到其年龄达到某个设定的值（比如15岁）， JVM 认为它很有可能是个“老不死的”对象，再呆在幸存区没有必要（而且老是在两个幸存区之间反复地复制也需要消耗资源），才会把它转移到老年代。 设置 Survivor 空间的目的是让那些中等寿命的对象尽量在 Minor GC 时被干掉，最终在总体上减少虚拟机的垃圾收集过程对用户程序的影响。 为什么不是1个 Survivor 空间？ 新生代一般都采用复制算法进行垃圾收集。原始的复制算法是把一块内存一分为二， gc 时把存活的对象从一块空间（From space）复制到另外一块空间（To space），再把原先的那块内存（From space）清理干净，最后调换 From space 和 To space 的逻辑角色 在 HotSpot 虚拟机里， Eden 空间和 Survivor 空间默认的比例是 8:1 。我们来看看在只有一个 Survivor 空间的情况下，这个 8:1 会有什么问题。此处为了方便说明，我们假设新生代一共为 9 MB 。对象优先在 Eden 区分配，当 Eden 空间满 8 MB 时，触发第一次 Minor GC 。比如说有 0.5 MB 的对象存活，那这 0.5 MB 的对象将由 Eden 区向 Survivor 区复制。这次 Minor GC 过后， Eden 区被清理干净， Survivor 区被占用了 0.5 MB ，还剩 0.5 MB 。到这里一切都很美好，但问题马上就来了：从现在开始所有对象将会在这剩下的 0.5 MB 的空间上被分配，很快就会发现空间不足，于是只好触发下一次 Minor GC 。可以看出在这种情况下，当 Survivor 空间作为对象“出生地”的时候，很容易触发 Minor GC ，这种 8:1 的不对称分配不但没能在总体上降低 Minor GC 的频率，还会把 gc 的时间间隔搞得很不平均。 为什么2个 Survivor 空间可以达到要求？ 我们把 Eden : From Survivor : To Survivor 空间大小设成 8 : 1 : 1 ，对象总是在 Eden 区出生， From Survivor 保存当前的幸存对象， To Survivor 为空。一次 gc 发生后： 1）Eden 区活着的对象 ＋ From Survivor 存储的对象被复制到 To Survivor ； 2) 清空 Eden 和 From Survivor ； 3) 颠倒 From Survivor 和 To Survivor 的逻辑关系： From 变 To ， To 变 From 。","categories":[{"name":"jvm","slug":"jvm","permalink":"https://kiddot.github.io/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://kiddot.github.io/tags/jvm/"}]},{"title":"JVM内存模型以及分区","slug":"JVM内存模型以及分区","date":"2017-06-28T10:51:22.000Z","updated":"2017-12-13T13:46:43.593Z","comments":true,"path":"2017/06/28/JVM内存模型以及分区/","link":"","permalink":"https://kiddot.github.io/2017/06/28/JVM内存模型以及分区/","excerpt":"JVM内存模型以及分区","text":"JVM内存模型以及分区 ​ 学习过C语言都知道，C编译器在划分内存区域的时候经常将管理的区域划分为数据段和代码段，数据段包括堆、栈以及静态数据区。那在Java语言当中，内存又是如何划分的？ ​ 我们在谈Java内存区域划分的时候事实上是指JVM内存区域划分。在讨论JVM内存区域划分之前，先来看一下Java程序具体执行的过程： Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀) JVM中的类加载器加载各个类的字节码文件 加载完毕之后，交由JVM执行引擎执行 ​ 在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存 运行时数据区包括哪几部分，以及存储了哪些数据程序计数器 ​ 在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。 ​ JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示 执行哪条指令的。 ​ 由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。 ​ 在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。 ​ 由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory) Java栈 与C语言中的数据段中的栈类似 ​ Java栈是Java方法执行的内存模型 ​ Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。 ​ 由此可以得出三个结论：一、线程当前执行的方法对应的栈帧必定位于Java栈的顶部。 二、因为栈的空间是有限的，所以在使用递归的时候，会因为执行方法的次数太多导致栈帧不足以存放在栈中而发生栈内存溢出现象，即栈溢出。三、栈空间的分配与释放都是由系统自动实施管理的。 局部变量表 用来存储方法中的局部变量。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的 操作数栈 协助完成程序中所有的计算过程 指向运行时常量池的引用 在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量 方法返回地址 当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址 ps：每个线程都会有一个自己的Java栈 本地方法栈 ​ 本地方法栈与Java栈的作用和原理非常相似。区别是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。 ​ 在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。 堆 ​ 在C语言中，堆这部分空间是唯一一个程序员可以管理的内存区域。但是在java中基本不用关心空间的释放问题，因为Java的GC机制。这部分空间也是Java垃圾收集器管理的主要区域。 ​ Java中的堆是用来存储对象本身的以及数组（数组引用是存放在Java栈中的）。 ​ 堆是被所有线程共享的，在JVM中只有一个堆。 方法区 与堆一样，是被线程共享的区域 ​ 在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。 ​ 在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。 ​ 运行时常量池,是方法区中非常重要的部分，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载的JVM后，对应的运行时常量池就被创建出来。但不仅是Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。 在JVM规范中，没有强制要求方法区必须实现垃圾回收。所以许多人称之为永久代。 扩展：JDK7数据存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。JDK8永久代的废弃。 为什么要废除永久代？ 永久代内存经常不够用或发生内存泄露，爆出异常java.lang.OutOfMemoryError: PermGen。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。 字符串存在永久代中，容易出现性能问题和内存溢出。 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。 ​ 用什么代替永久代 元空间。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 JDK8中类加载（方法区的功能）已经不在永久代PerGem中了，而是Metaspace（元空间）中","categories":[{"name":"jvm","slug":"jvm","permalink":"https://kiddot.github.io/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://kiddot.github.io/tags/jvm/"}]}]}